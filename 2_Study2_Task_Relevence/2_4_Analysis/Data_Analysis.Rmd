---
title: "DataAnalysis"
author: "wujiaqi"
date: "2025-04-25"
output: html_document
---

# 配置环境与R包
```{r}
###################### 配置环境与R包 ######################

# 配置环境
if (.Platform$OS.type == 'windows') {
        Sys.setlocale(category = 'LC_ALL','en_US.UTF-8')   # 使用UTF-8编码
} 

# setwd("C:/1_Postgraduate/TaskRelevance/2_Study2_Task_Relevence/2_4_Analysis")   # 设置工作目录

set.seed(42)   # 随机种子，确保结果可复现

rm(list = ls())   # 清除当前工作环境中所有对象（变量、函数等）

curDir = getwd()   # 获取当前工作路径

figDir = file.path(curDir, 'figures')   # 设置图片存储地址

# 安装cmdstanr作为后端
if (!require(cmdstanr)){
        install.packages("cmdstanr", repos = c('https://stan-dev.r-universe.dev', getOption("repos")))
        library(cmdstanr)
}
set_cmdstan_path('C:/softwares/cmdstan-2.36.0')



# 配置R包
if (!require(pacman)){
        install.packages("pacman")
        library(pacman)
}

## 使用pacman管理R包
pacman::p_load(
  'knitr',
  'here',         # 选择路径
  'tidyverse',    # 数据处理
  'ggplot2',      # 数据可视化
  'brms',         # 贝叶斯统计
  'bayesplot',    # 贝叶斯绘图
  'tidybayes',    # 贝叶斯统计
  'ggridges',     # 绘制山脊图
  'patchwork',    # 将多个图拼接在一起
  "papaja",       # 生成符合APA格式的文档
  'cmdstanr',
  'see',   # 后验推断结果可视化
  'bayestestR', 
  'parameters',
  'performance',
  'BayesFactor',   # 计算贝叶斯因子
  'report'   # 结果报告
               )

theme_set(theme_modern())

```

# 数据准备
## 1、读取数据
```{r warning=FALSE}
###################### 数据准备 ######################

df_raw <- list.files(file.path("../2_3_RawData"), pattern = "exp2_.*\\.csv$") %>%
  # 对读取到的所有.out文件x都执行函数read.table
  lapply(function(x)
    read.csv(file.path("../2_3_RawData", x), header = TRUE)) %>%
  # 读取被试人口学信息
  lapply(
    function(df)
      mutate(
        df,
        gender = jsonlite::fromJSON(response[5]),
        year = jsonlite::fromJSON(response[6])$Q0,
        education = jsonlite::fromJSON(response[7])$Q0,
        dist = view_dist_mm[9],
        rt = as.numeric(rt),
        success = as.character(success),
        timeout = as.character(timeout),
        correct = as.character(correct),
        ismatch = as.character(ismatch),
        correct = gsub("TRUE", "true", correct),
        ismatch = tolower(ismatch),
      )
  ) %>%
  bind_rows()
```

```{r}
# 计算平均LPD与视距

df_dist <- df_raw%>%
  dplyr::filter(trial_type == 'virtual-chinrest')%>%
  dplyr::summarize(px2mm_m = mean(px2mm),
          view_dist_mm_m = mean(view_dist_mm)
          )%>%
  # 计算视角
  dplyr::mutate(
    cross = 2 * atan((40 / px2mm_m) / (2 * view_dist_mm_m)) * (180/pi),
    shape = 2 * atan((190 / px2mm_m) / (2 * view_dist_mm_m)) * (180/pi),
    text_h = 2 * atan((80 / px2mm_m) / (2 * view_dist_mm_m)) * (180/pi),
  )
df_dist
```


## 2、数据清洗
```{r}
###################### 数据清洗 ######################

df <- df_raw %>%
  dplyr::select(
    subj_idx,
    gender,    # 男0女1
    year,
    rt,
    correct,    # 正确与否
    key_press,    # 被试按键
    shapes,    # 自变量Identity（图形所代表的身份）
    paired_colors,    # 配对的颜色
    ismatch,    # 自变量ismatch，match为1，mismatch为0
    condition,    # 自变量任务相关性
    trial_type,    # 插件类型
  ) %>%
  # 选择正式实验试次
  dplyr::filter(trial_type == "psychophysics" &
                  condition != "TR_prac" &
                  condition != "TIR_prac") %>%
  # 再次剔除无关变量
  dplyr::mutate(
    year = as.numeric(year),
    year = 2025 - year,
    acc = ifelse(correct == "true", 1, 0),
    ismatch = ifelse(ismatch == "true", 1, 0),
    TaskRelevance = case_when(
      condition == "TR_main" ~ "TaskRelevant",
      condition == "TIR_main" ~ "TaskIrrelevant"
    ),
    Identity = case_when(
      shapes == "自我" ~ "self",
      shapes == "朋友" ~ "friend",
      shapes == "生人" ~ "stranger",
    ),
  ) %>%
  dplyr::select(-trial_type, -correct, -condition, -shapes)


df

# length(unique(df$subj_idx))   # 查看被试总数
# 39

```

```{r}
# 正确率低于0.7的被试
df.excld.sub <-  df %>%
        dplyr::group_by(subj_idx) %>%
        dplyr::summarise(N = length(acc),                   
                         N_crrct = sum(acc),
                         ACC = sum(acc)/length(acc)) %>%
        dplyr::filter(ACC < 0.7) %>%                        
        dplyr::select(subj_idx)


# 无效试次占比
df.invalid_trial_rate <- df %>%
  dplyr::filter(!(subj_idx %in% df.excld.sub$subj_idx)) %>%   
  dplyr::summarize(rate = sum((is.na(key_press)) | (acc == 1 & rt <= 200))/length(rt)) #计算没反应的试次以及正确但rt<200ms的试占比
# 0.00020774	

# 有效数据框
df.v<- df %>%
  dplyr::filter(!(subj_idx %in% df.excld.sub$subj_idx)) %>%   # 选出正确率高于0.7的被试
  dplyr::filter(!is.na(key_press)) %>%   # 筛选出有反应的试次
  dplyr::filter(! (rt <= 200 & acc == 1))   # 筛选出RT>200ms的试次

df.v

# summary(df.v$rt)
```


## 3、JASP数据格式
```{r}
# # JASP 贝叶斯重复测量方差分析数据框
# df.v.jasp <- df.v%>%
#   dplyr::mutate(
#     ismatch = case_when(ismatch == "1" ~ "match", ismatch == "0" ~ "mismatch", )
#   )
# 
# # 计算每个被试的RT均值
# df.rt.jasp <- df.v.jasp %>%
#   dplyr::filter(acc == 1) %>%
#   dplyr::group_by(subj_idx, TaskRelevance, Identity, ismatch) %>%
#   dplyr::summarise(RT_m = mean(rt), .groups = 'drop') %>%
#   tidyr::pivot_wider(names_from = c("TaskRelevance", "Identity", "ismatch"),
#               values_from = "RT_m") 
# 
# # 计算每个被试的ACC
# df.acc.jasp <- df.v.jasp %>%
#   dplyr::group_by(subj_idx, TaskRelevance, Identity, ismatch) %>%
#   dplyr::summarise(ACC = sum(acc) / length(acc), .groups = 'drop') %>%
#   tidyr::pivot_wider(names_from = c("TaskRelevance", "Identity", "ismatch"),
#               values_from = "ACC") 
# 
# # 计算每个被试的η
# df.rt.long <- df.rt.jasp%>%
#   tidyr::pivot_longer(cols = -subj_idx,
#                names_to = c("TaskRelevance", "Identity", "ismatch"),
#                names_sep = "_",
#                values_to = "RT_m")
# 
# df.acc.long <- df.acc.jasp%>%
#   tidyr::pivot_longer(cols = -subj_idx,
#                names_to = c("TaskRelevance", "Identity", "ismatch"),
#                names_sep = "_",
#                values_to = "ACC")
# 
# df.η.jasp <- df.rt.long %>%
#   dplyr::inner_join(df.acc.long, by = c("subj_idx", "TaskRelevance", "Identity", "ismatch")) %>%
#   dplyr::mutate(η = ifelse(ACC == 0, NA, RT_m / ACC)) %>%
#   dplyr::select(subj_idx, TaskRelevance, Identity, ismatch, η)%>%
#   tidyr::pivot_wider(names_from = c("TaskRelevance", "Identity", "ismatch"),
#               values_from = "η")
# 
# # 计算每个被试的d prime
# df.dprime.jasp <- df.v.jasp%>%
#     dplyr::group_by(subj_idx, TaskRelevance, Identity) %>%   # 输入除ismatch外另外两个自变量
#     dplyr::summarise(
#       match_trials = sum(ismatch == "match"),   # 匹配试次总数
#       hits = sum(ismatch == "match" & acc == 1),   # 匹配情况下，正确识别为匹配
#       nonmatch_trials = sum(ismatch == "mismatch"),   # 不匹配试次总数
#       false_alarms = sum(ismatch == "mismatch" & acc == 0),   # 不匹配情况下，错误识别为匹配
#       .groups = 'drop'
#     ) %>%
#     dplyr::mutate(
#       # 处理极端值：# 如果击中为1，则调整为1 - 1/(2N)；如果为0则调整为1/(2N)，否则按照hits/match_trials计算
#       HR = ifelse(hits/match_trials == 1, 1 - 1/(2*match_trials),   
#                  ifelse(hits/match_trials == 0, 1/(2*match_trials), hits/match_trials)),
#       FAR = ifelse(false_alarms/nonmatch_trials == 1, 1 - 1/(2*nonmatch_trials),
#                   ifelse(false_alarms/nonmatch_trials == 0, 1/(2*nonmatch_trials), false_alarms/nonmatch_trials)),
#       dprime = qnorm(HR) - qnorm(FAR)   # 计算d prime
#     )%>%
#   dplyr::select(subj_idx, TaskRelevance, Identity, dprime)%>%
#   tidyr::pivot_wider(names_from = c("TaskRelevance", "Identity"),
#               values_from = "dprime")

# jasp_path <- "C:/1_Postgraduate/TaskRelevance/2_Study2_Task_Relevence/2_4_Analysis/Jasp"
# write_excel_csv(df.rt.jasp, file = file.path(here('2_Study2_Task_Relevence', '2_4_Analysis', 'Jasp'), "exp2_rt_jasp.csv"))
# write_excel_csv(df.acc.jasp, file = file.path(here('2_Study2_Task_Relevence', '2_4_Analysis', 'Jasp'), "exp2_acc_jasp.csv"))
# write_excel_csv(df.dprime.jasp, file = file.path(here('2_Study2_Task_Relevence', '2_4_Analysis', 'Jasp'), "exp2_dprime_jasp.csv"))
```


```{r}
# JASP 配对样本t检验数据格式

# unique_conditions <- unique(df.acc$TaskRelevance)   # 获取 TaskRelevance 列的所有唯一值
# 
# # ACC数据
# for (cond in unique_conditions) {
#         filtered_data <- df.acc.jasp %>% filter(TaskRelevance == cond)
#         file_name <- paste0("exp2_", cond, "_acc", ".csv")   # 构造文件名
#         write_excel_csv(filtered_data, file_name)   # 将筛选后的数据保存为 CSV 文件
# }
# 
# # RT数据
# for (cond in unique_conditions) {
#         filtered_data <- df.rt.jasp %>% filter(TaskRelevance == cond)
#         file_name <- paste0("exp2_", "rt_", cond, ".csv")
#         write_excel_csv(filtered_data, file = file.path(base_path, file_name))
# }
```


## 4、被试人口学信息统计
```{r}
# 基于有效被试的人口学信息统计
df.basic <- df.v %>%
        dplyr::select(subj_idx, year, gender) %>%
        dplyr::distinct(subj_idx, .keep_all = TRUE) %>%     # 根据subject去重，保留完整行
        dplyr::summarise(N = length(subj_idx),
                         Nf = length(gender[gender == "1"]),   # 计算女性人数
                         Nm = length(gender[gender == "0"]),   # 计算男性人数
                         Age_mean = round(mean(year,na.rm=TRUE),2),
                         Age_sd = round(sd(year,na.rm=TRUE),2)
        )
df.basic
```


# 数据预览
```{r}
# 计算每个被试的RT均值与ACC
df.subj.rt_m <- df.v %>%
        dplyr::filter(acc == 1) %>%
        dplyr::group_by(subj_idx, TaskRelevance, Identity, ismatch) %>%
        dplyr::summarise(RT_m = mean(rt),
                         RT_SD = sd(rt),
                         RT_SE = RT_SD/sqrt(n()-1),
                         Ntrial = length(rt),
                         .groups = 'drop') 

df.subj.acc <- df.v %>%
        dplyr::group_by(subj_idx, TaskRelevance, Identity, ismatch) %>%
        dplyr::summarise(N = length(acc),      
                         N_crrct = sum(acc),
                         ACC = sum(acc)/length(acc),
                         .groups = 'drop')

```

## 1、RT数据
```{r}
# 一个数据点表示一个被试均值

# 组织用于绘图的数据格式
df.rt.plot <- df.subj.rt_m %>%
  dplyr::mutate(
    ismatch = case_when(ismatch == "1" ~ "match", ismatch == "0" ~ "mismatch"),
    conds = case_when(
      ismatch == "match" & Identity == "self" ~ 0.7,
      ismatch == "match" & Identity == "friend" ~ 1,
      ismatch == "match" & Identity == "stranger" ~ 1.3,
      ismatch == "mismatch" & Identity == "self" ~ 1.7,
      ismatch == "mismatch" & Identity == "friend" ~ 2,
      ismatch == "mismatch" & Identity == "stranger" ~ 2.3,
    ),
    # conds = factor(conds),
    TaskRelevance = factor(TaskRelevance, 
                           levels = c("TaskRelevant", "TaskIrrelevant"),
                           labels = c("任务有关", "任务无关")),
    Identity = factor(Identity, levels = c("self", "friend", "stranger"), labels = c("自我", "朋友", "生人"))
  )

# 计算各条件均值与标准误
df.cond.rt_m <- df.rt.plot %>% 
  dplyr::group_by(TaskRelevance, Identity, ismatch, conds) %>%
  dplyr::summarise(RT_m = mean(RT_m),
                   RT_SD = mean(RT_SD),
                   RT_SE = mean(RT_SE),
                   n = n()) %>%
  dplyr::ungroup()

# 绘制各条件均值
plot_cond_rt_m <- df.cond.rt_m %>%
  ggplot2::ggplot(., 
                  aes(x = conds, 
                      y = RT_m,
                      group = Identity,
                      color = Identity)) +
  ggplot2::geom_line(position = position_dodge(0.9), alpha = 0.6) +
  ggplot2::geom_point(size = 3,
                      position = position_dodge(0.9)) + 
  ggplot2::geom_errorbar(aes(ymin=RT_m-RT_SE,
                             ymax=RT_m+RT_SE),
                         width=.1,
                         position = position_dodge(0.9)) +
  ggplot2::facet_wrap(~TaskRelevance)+
  papaja::theme_apa()

# 绘制各条件均值+每个被试均值
plot_rt_m <- plot_cond_rt_m +
    ggplot2::geom_point(data = df.rt.plot,
                       aes(x = conds, y = RT_m, group = as.factor(subj_idx)),
                      position = position_dodge(0.08),
                      color="#000000",
                      alpha = 0.05) +
  ggplot2::geom_line(data = df.rt.plot,
                     aes(x = conds,
                         y = RT_m,
                         group = as.factor(subj_idx)),
                     position = position_dodge(0.08),
                     linetype = 1,
                     linewidth=0.8,
                     color="#000000",
                     alpha=0.05) +
  ggplot2::scale_x_continuous(breaks = c(1, 2), labels = c("匹配", "不匹配")) +
  ggplot2::labs(y = "反应时", x = NULL) +
  ggplot2::scale_color_discrete(name = "身份")

plot_rt_m
# ggplot2::ggsave(file.path(figDir, "RT_observed_data.png"))


```

```{r}
# 关闭所有异常的绘图设备（清空错乱状态）
graphics.off()  
# 重新打开IDE的默认绘图设备（RStudio会自动关联Plots面板）
dev.new()    
```


## 2、ACC数据
```{r}
# 一个数据点表示一个被试均值

# 组织用于绘图的数据格式
df.acc.plot <- df.subj.acc %>%
  dplyr::mutate(
    ismatch = case_when(ismatch == "1" ~ "match", ismatch == "0" ~ "mismatch"),
    conds = case_when(
      ismatch == "match" & Identity == "self" ~ 0.7,
      ismatch == "match" & Identity == "friend" ~ 1,
      ismatch == "match" & Identity == "stranger" ~ 1.3,
      ismatch == "mismatch" & Identity == "self" ~ 1.7,
      ismatch == "mismatch" & Identity == "friend" ~ 2,
      ismatch == "mismatch" & Identity == "stranger" ~ 2.3,
    ),
    TaskRelevance = factor(TaskRelevance, 
                           levels = c("TaskRelevant", "TaskIrrelevant"),
                           labels = c("任务有关", "任务无关")),
    Identity = factor(Identity, levels = c("self", "friend", "stranger"), labels = c("自我", "朋友", "生人"))
  )


# 计算各条件均值
df.cond.acc <- df.acc.plot %>% 
  dplyr::group_by(TaskRelevance, Identity, ismatch, conds) %>%
  dplyr::summarise(ACC = mean(ACC),
                   n = n()) %>%
  dplyr::ungroup()

# 绘制各条件均值
plot_cond_acc <- df.cond.acc %>%
  ggplot2::ggplot(., 
                  aes(x = conds,
                      y = ACC,
                      group = Identity,
                      color = Identity)) +
  ggplot2::geom_line(position = position_dodge(0.9), alpha = 0.6) +
  ggplot2::geom_point(size = 3,
                      position = position_dodge(0.9)) + 
  ggplot2::facet_wrap(~TaskRelevance)+
  papaja::theme_apa()

# 绘制各条件均值+每个被试均值
plot_acc <- plot_cond_acc +
    ggplot2::geom_point(data = df.acc.plot,
                       aes(x = conds, y = ACC, group = as.factor(subj_idx)),
                      position = position_dodge(0.08),
                      color="#000000",
                      alpha = 0.05) +
  ggplot2::geom_line(data = df.acc.plot,
                     aes(x = conds,
                         y = ACC,
                         group = as.factor(subj_idx)),
                     position = position_dodge(0.08),
                     linetype = 1,
                     linewidth=0.8,
                     color="#000000",
                     alpha=0.05) +
  ggplot2::scale_x_continuous(breaks = c(1, 2), labels = c("匹配", "不匹配")) +
  ggplot2::labs(y = "正确率", x = NULL) +
  ggplot2::scale_color_discrete(name = "身份")

plot_acc
# ggplot2::ggsave(file.path(figDir, "ACC_observed_data.png"))

```

# 样本量计算：贝叶斯因子序列分析
```{r}
# 关注自我与任务无关时：Identity*ismatch的交互效应：>10或者<1/10
# 自我与任务有关数据
df.tr.subj <- df.subj.rt_m %>%
  dplyr::filter(TaskRelevance == "TaskRelevant") %>%
  dplyr::mutate(Identity = factor(Identity, levels = c("self", "friend", "stranger")),
                ismatch = factor(ismatch, levels = c("1", "0"))                )

BF_tr_rt <- BayesFactor::anovaBF(RT_m ~ Identity * ismatch, df.tr.subj, progress = FALSE)
bayestestR::bayesfactor_inclusion(BF_tr_rt, match_models = TRUE)


# 自我与任务无关数据
df.tir.subj <- df.subj.rt_m %>%
  dplyr::filter(TaskRelevance == "TaskIrrelevant") %>%
  dplyr::mutate(Identity = factor(Identity, levels = c("self", "friend", "stranger")),
                ismatch = factor(ismatch, levels = c("1", "0")))

BF_tir_rt <- BayesFactor::anovaBF(RT_m ~ Identity * ismatch, df.tir.subj, progress = FALSE)
bayestestR::bayesfactor_inclusion(BF_tir_rt, match_models = TRUE)
```

# Bootstrap
```{r}
# Step1: 根据自变量分组，将每个组合下的RT与ACC变为一个数据点(RT,ACC)
## 1.1 合并RT与ACC数据框，一行表示一个被试
df_combined <- df.subj.rt_m %>%
  dplyr::left_join(df.subj.acc, by = c("subj_idx", "TaskRelevance", "Identity", "ismatch")) %>%
  dplyr::select(subj_idx, TaskRelevance, Identity, ismatch, RT_m, ACC)

## 1.2 获取每个条件组合下的数据框列表
df_list <- df_combined %>%
  dplyr::group_by(TaskRelevance, Identity, ismatch) %>%
  dplyr::group_split() %>%
  stats::setNames(
    map_chr(., ~ paste(.x$TaskRelevance[1], .x$Identity[1], .x$ismatch[1], sep = "_"))
  ) %>%
  purrr::map(~ select(., RT_m, ACC))
# names(df_list)
# df_list[["TIR_main_朋友_0"]]   # 访问某个实验条件下的数据框



# Step2: 进行一次有放回重采样，采样次数为单个条件的样本量；计算重采样样本的RT与ACC均值；重复k次
## 2.1 定义重采样函数
bootstrap_sample <- function(data) {
  n <- nrow(data)   # 一行一个被试，获取实验条件下的样本量
  indices <- sample(1:n, replace = TRUE, size = n)   # 从1：n中进行有放回抽样，抽取size次，返回一串索引
  bootstrap_sample <- data[indices, ]   # 通过索引获取重采样数据，获取索引所在行，组合为重采样数据框1
  return(bootstrap_sample)
}

## 2.2定义函数对每个条件数据点(RT,ACC)进行重采样与均值计算
run_bootstrap_analysis <- function(data_list, k = 2000) {
  results <- list()
  set.seed(42)
  for (condition_name in names(data_list)) {
    data <- data_list[[condition_name]]   # 获取每个实验条件的数据点
    
    mean_rt <- numeric(k)
    mean_acc <- numeric(k)
    for (i in 1:k) {
      bootstrap_sample_data <- bootstrap_sample(data)   # 进行一次重采样
      mean_rt[i] <- mean(bootstrap_sample_data$RT_m)   # 计算单次重采样样本的RT均值
      mean_acc[i] <- mean(bootstrap_sample_data$ACC)   # 计算单次重采样样本的ACC均值
    }
    results[[condition_name]] <- data.frame(   # 存储每个实验条件下的重采样均值结果
      condition = condition_name,
      mean_rt = mean_rt,
      mean_acc = mean_acc
    )
  }
  return(bind_rows(results))
}

## 2.3 使用函数
bootstrap_results <- run_bootstrap_analysis(df_list, k = 2000)



# Step3: 以acc为X轴，RT为Y轴，按匹配情况分为2个子图，子图内图例为标签，统一坐标轴范围和刻度
## 3.1 整理用于画图的数据格式
bootstrap_results_plot <- bootstrap_results %>%
  tidyr::separate(condition,
           into = c("TaskRelevance", "Identity", "ismatch"),
           sep = "_") %>%
  dplyr::mutate(
    ismatch = factor(
      ifelse(ismatch == "0", "不匹配", "匹配"),
      levels = c("匹配", "不匹配")),
    TaskRelevance = factor(
      case_when(TaskRelevance == "TaskRelevant" ~ "任务有关", TaskRelevance == "TaskIrrelevant" ~ "任务无关"),
      levels = c("任务有关", "任务无关")),
    Identity = factor(
      case_when(Identity == "self" ~ "自我", Identity == "friend" ~ "朋友", Identity == "stranger" ~ "生人"),
      levels = c("自我", "朋友", "生人"))
  ) %>%
  dplyr::relocate(mean_rt, mean_acc, .after = last_col())

bootstrap_results_plot

## 3.2 画图
plot_bootstrap <- ggplot(bootstrap_results_plot, aes(x = mean_acc, y = mean_rt, color = Identity)) +
  geom_point(alpha = 0.4, size = 2) +  # 添加透明度使重叠点可见
  facet_grid(ismatch ~ TaskRelevance) +  # 按TaskRelevance和ismatch分面
  labs(
    title = "Bootstrapping",
    x = "正确率", 
    y = "反应时(ms)",
    color = "身份"
  ) +
  ylim(500, 900) +
  xlim(0.6, 1.0) +
  theme_apa() +
  theme(
    legend.position = "bottom",
    strip.text = element_text(face = "bold"),
    panel.spacing = unit(1, "lines")  # 增加面板间距
  )

print(plot_bootstrap)
ggsave(file.path(figDir, "Bootstrap.png"))
```

# 贝叶斯层级模型
```{r}
# 数据整理
df.v.trial <- df.v %>%
  dplyr::mutate(
    saymatch = ifelse((ismatch == 1 & acc == 1) |
                              (ismatch == 0 & acc == 0), 1, 0),
    ismatch_num = ifelse(ismatch == 1, 0.5, -0.5),   # 用于RT建模
    
    Identity = factor(Identity, levels = c("自我", "朋友", "生人")),
  )%>%
  dplyr::select(subj_idx, TaskRelevance, Identity, ismatch, saymatch, ismatch_num, key_press, acc, rt )


# 自我与任务有关数据
df.tr.trial <- df.v.trial %>%
  dplyr::filter(TaskRelevance == "TaskRelevant")

# 自我与任务无关数据
df.tir.trial <- df.v.trial %>%
  dplyr::filter(TaskRelevance == "TaskIrrelevant")
```

## 1、任务有关RT
### （1）模型拟合
```{r}
# 使用ismatch_num拟合RT模型
var_both_tr_rt_model <- df.tr.trial %>%
  dplyr::mutate(rt_sec = rt / 1000) %>%
  dplyr::filter(acc == 1) %>%         # only correct trials
  brms::brm(
    rt_sec ~ Identity * ismatch_num +
      (Identity * ismatch_num | subj_idx),
    family = lognormal(),
    data = .,
    chains = 4,
    warmup = 1000,
    iter = 5000,
    thin = 1,
    control = list(adapt_delta = .95),
    cores = parallel::detectCores(),
    backend = 'cmdstanr',
    save_pars = save_pars(all = TRUE),
    file = file.path(curDir, "glmmModels/TR_RT_0.5")
  )

# 数据类型以及编码值
# rt_sec：数值型，取值范围为RT正常范围
# Identity：因子，自我为基线，取值为自我、朋友、生人
# ismatch_num：数值，值为-0.5（不匹配），0.5（匹配）
# subj_idx：数值
```

```{r}

# # 使用ismatch拟合RT模型
# var_both_tr_rt_model <- df.tr.trial %>%
#   dplyr::mutate(rt_sec = rt / 1000) %>%
#   dplyr::filter(acc == 1) %>%         # only correct trials
#   brms::brm(
#     rt_sec ~ Identity * ismatch +
#       (Identity * ismatch | subj_idx),
#     family = lognormal(),
#     data = .,
#     chains = 4,
#     warmup = 1000,
#     iter = 5000,
#     thin = 1,
#     control = list(adapt_delta = .95),
#     cores = parallel::detectCores(),
#     backend = 'cmdstanr',
#     save_pars = save_pars(all = TRUE),
#     file = file.path(curDir, "glmmModels/TR_RT_1")
#   )

# 数据类型以及编码值
# rt_sec：数值型，取值范围为RT正常范围
# Identity：因子，自我为基线，取值为自我、朋友、生人
# ismatch：数值，值为0（不匹配），1（匹配）
# subj_idx：数值


# summary(var_both_tr_rt_model)

# 固定效应
#                      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
# Intercept               -0.21      0.02    -0.24    -0.17 1.00     1807     3998 # 不匹配:logRT自我
# Identity朋友             0.02      0.01     0.00     0.03 1.00    16012    12875 # 不匹配:logRT朋友-logRT自我
# Identity生人             0.00      0.01    -0.01     0.02 1.00    15521    13832 # 不匹配:logRT生人-logRT自我
# ismatch                 -0.13      0.01    -0.16    -0.10 1.00     7656    10328 # (logRT匹配 - logRT不匹配)自我
# Identity朋友:ismatch     0.01      0.02    -0.04     0.04 1.00     8816    11531 # (logRT匹配 - logRT不匹配)朋友 - (logRT匹配 - logRT不匹配)自我
# Identity生人:ismatch     0.08      0.02     0.04     0.11 1.00     8151    10773 # (logRT匹配 - logRT不匹配)生人 - (logRT匹配 - logRT不匹配)自我

```


### （2）模型评估
```{r}
# ESS、Rhat
summary(var_both_tr_rt_model)

# Regression Coefficients:
#                          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
# Intercept                   -0.27      0.02    -0.31    -0.24 1.00      802     1763  # ismatch_num为0时（匹配和不匹配的均值），logRT自我
# Identity朋友                 0.02      0.01    -0.01     0.04 1.00     1368     3005  # ismatch_num为0时（匹配和不匹配的均值），logRT朋友-logRT自我
# Identity生人                 0.04      0.01     0.02     0.06 1.00     2253     4618  # ismatch_num为0时（匹配和不匹配的均值），logRT生人-logRT自我
# ismatch_num                 -0.13      0.01    -0.16    -0.10 1.00     2334     5170  # (logRT匹配 - logRT不匹配)自我
# Identity朋友:ismatch_num     0.01      0.02    -0.03     0.04 1.00     1703     3912  # (logRT匹配 - logRT不匹配)朋友 - (logRT匹配 - logRT不匹配)自我
# Identity生人:ismatch_num     0.08      0.02     0.04     0.11 1.00     2273     5162  # (logRT匹配 - logRT不匹配)生人 - (logRT匹配 - logRT不匹配)自我


# 6个条件下的logRT
# Mismatch:self       - Intercept
# Mismatch:friend     - Intercept  + Identity朋友
# Mismatch:stranger   - Intercept  + Identity生人
# Match:self          - Intercept  + ismatch
# Match:friend        - Intercept  + ismatch + Identity朋友+ Identity朋友:ismatch
# Match:stranger      - Intercept  + ismatch + Identity生人+ Identity生人:ismatch

```

```{r}
# 轨迹图(改)
target_pars <- c(
  "b_Intercept",
  "b_Identity朋友",
  "b_Identity生人",
  "b_ismatch_num",
  "b_Identity朋友:ismatch_num",
  "b_Identity生人:ismatch_num"
  )

trace_plot <- bayesplot::mcmc_trace(
  var_both_tr_rt_model, 
  pars = target_pars,
  facet_args = list(nrow = 2, ncol = 3))+
    ggplot2::theme(
    axis.text.x = ggplot2::element_text(
      angle = 45,  # 横坐标文字旋转45度
      hjust = 1,   # 文字右对齐，贴合坐标轴
      vjust = 1,   # 垂直对齐
      size = 10     # 适度缩小字体
    ),
    axis.text.y = ggplot2::element_text(size = 10),
    strip.text = ggplot2::element_text(size = 8),
    legend.title = ggplot2::element_text(size = 12),  # 图例标题
    legend.text = ggplot2::element_text(size = 10),   # 图例文字
  )
trace_plot
ggsave(file.path(figDir, "trace_plot.png"))
```

```{r}
# 概率密度曲线
p_sample <- bayestestR::estimate_density(var_both_tr_rt_model)
plot(p_sample)
# ggsave(file.path(figDir, "parameters_distribution.png"))

# 同时绘制采样分布与轨迹图
# p_dens <- mcmc_plot(RT_m1, type = "dens", pars = "^b_")
# p_trace <- mcmc_plot(RT_m1, type = "trace", pars = "^b_")
# p_dens + p_trace
```


### （3）模型比较
```{r}
# MAE
calculate_MAE <- function(model_ppc, original_data, y_var = "log_RTs") {
  # 计算每个观测的后验预测均值
  pre_y_mean <- colMeans(model_ppc)
  
  # 构建数据框：预测均值 + 原始观测值
  MAE_df <- data.frame(
    RT_ppc_mean = pre_y_mean,
    RT_original = original_data[[y_var]]  # 提取指定的响应变量观测值
  )
  
  # 计算绝对预测误差
  MAE_df <- MAE_df %>%
    mutate(pre_error = abs(RT_original - RT_ppc_mean))
  
  # 计算误差的中位数
  MAE_value <- median(MAE_df$pre_error, na.rm = TRUE)
  
  return(MAE_value)
}

# 后验预测
rt_var_both_ppc <- posterior_predict(
  object = var_both_tr_rt_model,
)

rt_var_both_mae <- calculate_MAE(rt_var_both_ppc, var_both_tr_rt_model$data, "rt_sec")
#  0.08841838
```

```{r}
# loo
loo <- loo::loo(var_both_tr_rt_model)
```


### （4）后验预测检验
```{r}
# performance::check_predictions(RT_m1, check_range = TRUE)
bayesplot::pp_check(var_both_tr_rt_model, type = "dens_overlay", ndraws = 1000)
# ggsave(file.path(figDir, "modle_estimation.png"))
```


### （5）推断统计
```{r}
# 固定效应，各个条件下反应时分布
df_tr_rt_pop <- var_both_tr_rt_model %>%
  tidybayes::gather_draws(`b_.*`, regex = TRUE) %>%
  dplyr::rename(term = .variable,
                pop_mean = .value) %>%  # gather_draws会将变量存储为1列，所有的值存储为另一列
  dplyr::ungroup() %>%
  dplyr::mutate(term = gsub("b_", "", term))%>%
  tidyr::pivot_wider(names_from = c(term), values_from = pop_mean) %>%   # long to wide
  # 计算各条件反应时分布
  dplyr::mutate(
    Self_NonMatch = Intercept,   #  self和nonmatch被编码为0              
    Friend_NonMatch = Intercept  + Identity朋友,
    Stranger_NonMatch = Intercept  + Identity生人,
    Self_Match = Intercept + ismatch_num,             
    Friend_Match = Intercept + ismatch_num + Identity朋友 + `Identity朋友:ismatch_num`,
    Stranger_Match = Intercept + ismatch_num + Identity生人 + `Identity生人:ismatch_num`)%>%
  dplyr::select(`.chain`, `.iteration`, `.draw`,
                Self_Match, Friend_Match, Stranger_Match,
                Self_NonMatch, Friend_NonMatch, Stranger_NonMatch) %>%
  # wide to long
  tidyr::pivot_longer(cols = Self_Match:Stranger_NonMatch, names_to = "term", values_to =  "value") %>%  
  dplyr::mutate(term = factor(term, levels = c(
                'Self_Match', 'Friend_Match', 'Stranger_Match',
                'Self_NonMatch', 'Friend_NonMatch', 'Stranger_NonMatch'
  )),
  # log还原
  value = exp(value),
  value = value *1000)

df_tr_rt_pop
```


```{r}
# 固定效应，条件间差异分布
df_tr_rt_pop_diff_wide <- df_tr_rt_pop %>%
  tidyr::pivot_wider(names_from = c(term), values_from = value) %>%
  dplyr::mutate(
    diff_SF_Match = Friend_Match - Self_Match,
    diff_SStr_Match = Stranger_Match - Self_Match,
    diff_FStr_Match = Stranger_Match - Friend_Match,
    diff_SF_NonMatch = Friend_NonMatch - Self_NonMatch,
    diff_SStr_NonMatch = Stranger_NonMatch - Self_NonMatch,
    diff_FStr_NonMatch = Stranger_NonMatch - Friend_NonMatch
  ) %>%
  dplyr::select(`.chain`, `.iteration`, `.draw`,
    diff_SF_Match, diff_SStr_Match, diff_FStr_Match,
    diff_SF_NonMatch, diff_SStr_NonMatch, diff_FStr_NonMatch
  )

df_tr_rt_pop_diff_wide

```

```{r}
# 固定效应，后验分布描述
df_tr_rt_fixed <- df_tr_rt_pop%>%
  tidyr::pivot_wider(.,
                     id_cols = c('.chain', '.iteration', '.draw'),
                     names_from = term ) %>%
  dplyr::select(-c('.chain', '.iteration', '.draw')) %>%
  bayestestR::describe_posterior(.,
                                 ci = 0.95,
                                 ci_method = 'hdi',
                                 test = c("p_direction", "p_significance"),
                                 centrality = "median") %>%
  tidyr::separate(Parameter, c('Identity', 'ismatch')) %>%
  dplyr::mutate(Identity = factor(Identity, levels = c('Self', 'Friend', 'Stranger')),
                ismatch = factor(ismatch, levels = c('Match', 'NonMatch')))

summary(df_tr_rt_fixed)
```

```{r}
# 各条件中位数及可信区间

## 匹配条件
med_tr_rt_Self_Match<- round(df_tr_rt_fixed$Median[df_tr_rt_fixed$Identity == 'Self' & df_tr_rt_fixed$ismatch == 'Match'], digits = 0)
ll_tr_rt_Self_Match<- round(df_tr_rt_fixed$CI_low[df_tr_rt_fixed$Identity == 'Self' & df_tr_rt_fixed$ismatch == 'Match'], digits = 0)
ul_tr_rt_Self_Match<- round(df_tr_rt_fixed$CI_high[df_tr_rt_fixed$Identity == 'Self' & df_tr_rt_fixed$ismatch == 'Match'], digits = 0)

med_tr_rt_Friend_Match<- round(df_tr_rt_fixed$Median[df_tr_rt_fixed$Identity == 'Friend' & df_tr_rt_fixed$ismatch == 'Match'], digits = 0)
ll_tr_rt_Friend_Match<- round(df_tr_rt_fixed$CI_low[df_tr_rt_fixed$Identity == 'Friend' & df_tr_rt_fixed$ismatch == 'Match'], digits = 0)
ul_tr_rt_Friend_Match<- round(df_tr_rt_fixed$CI_high[df_tr_rt_fixed$Identity == 'Friend' & df_tr_rt_fixed$ismatch == 'Match'], digits = 0)

med_tr_rt_Stranger_Match<- round(df_tr_rt_fixed$Median[df_tr_rt_fixed$Identity == 'Stranger' & df_tr_rt_fixed$ismatch == 'Match'], digits = 0)
ll_tr_rt_Stranger_Match<- round(df_tr_rt_fixed$CI_low[df_tr_rt_fixed$Identity == 'Stranger' & df_tr_rt_fixed$ismatch == 'Match'], digits = 0)
ul_tr_rt_Stranger_Match<- round(df_tr_rt_fixed$CI_high[df_tr_rt_fixed$Identity == 'Stranger' & df_tr_rt_fixed$ismatch == 'Match'], digits = 0)


## 不匹配条件
med_tr_rt_Self_NonMatch<- round(df_tr_rt_fixed$Median[df_tr_rt_fixed$Identity == 'Self' & df_tr_rt_fixed$ismatch == 'NonMatch'], digits = 0)
ll_tr_rt_Self_NonMatch<- round(df_tr_rt_fixed$CI_low[df_tr_rt_fixed$Identity == 'Self' & df_tr_rt_fixed$ismatch == 'NonMatch'], digits = 0)
ul_tr_rt_Self_NonMatch<- round(df_tr_rt_fixed$CI_high[df_tr_rt_fixed$Identity == 'Self' & df_tr_rt_fixed$ismatch == 'NonMatch'], digits = 0)

med_tr_rt_Friend_NonMatch<- round(df_tr_rt_fixed$Median[df_tr_rt_fixed$Identity == 'Friend' & df_tr_rt_fixed$ismatch == 'NonMatch'], digits = 0)
ll_tr_rt_Friend_NonMatch<- round(df_tr_rt_fixed$CI_low[df_tr_rt_fixed$Identity == 'Friend' & df_tr_rt_fixed$ismatch == 'NonMatch'], digits = 0)
ul_tr_rt_Friend_NonMatch<- round(df_tr_rt_fixed$CI_high[df_tr_rt_fixed$Identity == 'Friend' & df_tr_rt_fixed$ismatch == 'NonMatch'], digits = 0)

med_tr_rt_Stranger_NonMatch<- round(df_tr_rt_fixed$Median[df_tr_rt_fixed$Identity == 'Stranger' & df_tr_rt_fixed$ismatch == 'NonMatch'], digits = 0)
ll_tr_rt_Stranger_NonMatch<- round(df_tr_rt_fixed$CI_low[df_tr_rt_fixed$Identity == 'Stranger' & df_tr_rt_fixed$ismatch == 'NonMatch'], digits = 0)
ul_tr_rt_Stranger_NonMatch<- round(df_tr_rt_fixed$CI_high[df_tr_rt_fixed$Identity == 'Stranger' & df_tr_rt_fixed$ismatch == 'NonMatch'], digits = 0)

```

```{r}
# 基于sexit框架进行统计推断（改）
bayestestR::sexit(df_tr_rt_pop_diff_wide[,c(4:9)])
```


### （6）结果可视化
```{r}
# 固定效应，后验分布均值图
plot(brms::conditional_effects(var_both_tr_rt_model),plot = FALSE)[3]
```


```{r}
# p1：绘制各个条件下反应时后验分布（固定效应）

## 固定效应均值
vlines <- df_tr_rt_pop %>%
  tidyr::separate(term, c('Identity', 'ismatch')) %>%
  dplyr::mutate(Identity = factor(Identity, levels = c('Self', 'Friend', 'Stranger'), labels = c("自我", "朋友", "生人")),
                ismatch = factor(ismatch, levels = c('Match', 'NonMatch'), labels = c("匹配", "不匹配"))) %>%
  dplyr::group_by(Identity, ismatch) %>%
  dplyr::summarize(Mean = mean(value))


## 各个条件RT后验分布
p_tr_rt <- df_tr_rt_pop %>%
  tidyr::separate(term, c('Identity', 'ismatch')) %>%
  dplyr::mutate(Identity = factor(Identity, levels = c('Self', 'Friend', 'Stranger'), labels = c("自我", "朋友", "生人")),
                ismatch = factor(ismatch, levels = c('Match', 'NonMatch'),labels = c("匹配", "不匹配"))) %>%
  ggplot2::ggplot(., aes(x = value, color = Identity)) +
  tidybayes::stat_halfeye(aes(fill = Identity), alpha = 0.6) +
  ggplot2::geom_vline(data = vlines,
             aes(xintercept = Mean, color = Identity),
             linetype = "dashed") +
  ggplot2::facet_wrap( ~ ismatch, nrow = 2) +
  ggplot2::scale_colour_brewer(palette = "Dark2") +
  ggplot2::scale_fill_brewer(palette = "Dark2")+
  ggplot2::labs(x = expression('反应时后验分布'),
                color = "身份",
                fill = "身份",
                )


# theme_apa()
p_tr_rt
# ggsave(file.path(figDir, "RT_pop_distribution.png"))
```

```{r}
# p2：绘制各个条件反应时差异的后验分布（固定效应）

# 绘图数据
df_tr_rt_pop_diff <- df_tr_rt_pop_diff_wide %>%
  # wide to long
  tidyr::pivot_longer(
    cols = diff_SF_Match:diff_FStr_NonMatch,
    names_to = "term_diff",
    values_to =  "value"
  ) %>%
  dplyr::mutate(term_diff = factor(
    term_diff,
    levels = c(
      'diff_SF_Match','diff_SStr_Match','diff_FStr_Match',
      'diff_SF_NonMatch', 'diff_SStr_NonMatch', 'diff_FStr_NonMatch'),
    labels = c(
      "(RT[自我] - RT[朋友])[匹配]",
      "(RT[自我] - RT[生人])[匹配]",
      "(RT[朋友] - RT[生人])[匹配]",
      "(RT[自我] - RT[朋友])[不匹配]",
      "(RT[自我] - RT[生人])[不匹配]",
      "(RT[朋友] - RT[生人])[不匹配]"
    )
  ))


p_tr_rt_diff <- df_tr_rt_pop_diff %>%
  ggplot2::ggplot(aes(x = value, fill = after_stat(x > 0))) +   # RT：self快于friend/stranger,用RT长的-短的
  tidybayes::stat_halfeye() +
  geom_vline(xintercept = 0, linetype = "dashed") + # 添加x=0的垂线
  scale_fill_manual(
    values = c('#E74C3C', '#2980B9'),# 蓝色出现在true组，红色出现在false组
    breaks = c(TRUE, FALSE),
    name = "反应时差异" ,
    labels = c(">0", "<0")# 标签yes表示x<0
  ) +
  xlab("各条件反应时差异后验分布") +
 facet_wrap( ~ term_diff, nrow = 2, 
              labeller = labeller(term_diff = label_parsed))

p_tr_rt_diff

# ggsave(file.path(figDir, "RT_diff_compare.png"))


```


```{r}
# 回归系数后验分布可视化（不重要，补充信息）

## HDI 是否包含0
RT_hdi <- bayestestR::hdi(var_both_tr_rt_model, ci = 0.95)
RT_hdi
plot(RT_hdi) + scale_fill_flat()


## 回归系数>0或<0的比例
RR_PD <- bayestestR::p_direction(var_both_tr_rt_model)
RR_PD
plot(RR_PD)

# 参数不为0的比例
RR_PS <- bayestestR::p_significance(var_both_tr_rt_model)
RR_PS
x <- plot(RR_PS)
# 提取颜色
g <- ggplot2::ggplot_build(x)
unique(g$data[[1]]$fill)
```

## 2、任务有关ACC：信号检测论
### （1）模型拟合
```{r}
# fit a three-level hierarchical model for RT, didn't specify the prior, lognormal, effective coding
var_both_tr_sdt_model <- brms::brm(saymatch ~ 0 + Identity + Identity:ismatch + 
                          (0 + Identity + Identity:ismatch | subj_idx),
                  family = bernoulli(link="probit"), 
                  data = df.tr.trial,
                  chains = 4,
                  warmup = 1000,
                  iter = 5000,# 5000
                  thin = 1,
                  control = list(adapt_delta = .95),
                  cores = parallel::detectCores(),
                  backend = 'cmdstanr',  # with cmdstanr
                  save_pars = save_pars(all = TRUE),
                  file = file.path(curDir, "glmmModels/TR_sdt")
                  )


# saymatch:数值
# Identity：因子，自我基线
# ismatch：数值，1匹配，0不匹配
```

### （2）模型评估
```{r}
# ESS、Rhat
summary(var_both_tr_sdt_model)

# Regression Coefficients:
#                      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
# Identity自我            -1.12      0.06    -1.25    -1.01 1.00     6806     9433   # ismatch为0时，自我的z分数
# Identity朋友            -1.14      0.06    -1.27    -1.02 1.00     8160     9194   # ismatch为0时，朋友的z分数
# Identity生人            -1.21      0.07    -1.35    -1.08 1.00     8021    10630   # ismatch为0时，生人的z分数
# Identity自我:ismatch     2.52      0.11     2.31     2.73 1.00     8175    11571   # （Z匹配-Z不匹配）自我
# Identity朋友:ismatch     2.49      0.11     2.28     2.71 1.00     8409    10793   # （Z匹配-Z不匹配）朋友
# Identity生人:ismatch     2.29      0.10     2.09     2.49 1.00     7751    10497   # （Z匹配-Z不匹配）生人
```

```{r}
# 轨迹图
target_pars <- c(
  "b_Identity自我",
  "b_Identity朋友",
  "b_Identity生人",
  "b_Identity自我:ismatch",
  "b_Identity朋友:ismatch",
  "b_Identity生人:ismatch"
  )

trace_plot <- bayesplot::mcmc_trace(
  var_both_tr_sdt_model, 
  pars = target_pars,
  facet_args = list(nrow = 2, ncol = 3))
trace_plot
# ggsave(file.path(figDir, "trace_plot.png"))
```

```{r}
# 概率密度曲线
p_sample <- bayestestR::estimate_density(var_both_tr_sdt_model)
plot(p_sample)
# ggsave(file.path(figDir, "parameters_distribution.png"))

# 同时绘制采样分布与轨迹图
# p_dens <- mcmc_plot(RT_m1, type = "dens", pars = "^b_")
# p_trace <- mcmc_plot(RT_m1, type = "trace", pars = "^b_")
# p_dens + p_trace
```


### （3）模型比较
```{r}
# MAE
calculate_MAE <- function(model_ppc, original_data, y_var = "log_RTs") {
  # 计算每个观测的后验预测均值
  pre_y_mean <- colMeans(model_ppc)
  
  # 构建数据框：预测均值 + 原始观测值
  MAE_df <- data.frame(
    RT_ppc_mean = pre_y_mean,
    RT_original = original_data[[y_var]]  # 提取指定的响应变量观测值
  )
  
  # 计算绝对预测误差
  MAE_df <- MAE_df %>%
    mutate(pre_error = abs(RT_original - RT_ppc_mean))
  
  # 计算误差的中位数
  MAE_value <- median(MAE_df$pre_error, na.rm = TRUE)
  
  return(MAE_value)
}

# 后验预测
tr_sdt_var_both_ppc <- posterior_predict(
  object = var_both_tr_sdt_model,
)

tr_sdt_var_both_mae <- calculate_MAE(tr_sdt_var_both_ppc, var_both_tr_sdt_model$data, "saymatch")

# 0.11731

```

```{r}
# loo
loo <- loo::loo(var_both_tr_sdt_model)
```


### （4）后验预测检验
```{r}
# performance::check_predictions(RT_m1, check_range = TRUE)
bayesplot::pp_check(var_both_tr_sdt_model, type = "dens_overlay", ndraws = 1000)
# ggsave(file.path(figDir, "modle_estimation.png"))
```


### （5）推断统计
```{r}
# 固定效应，各个条件下参数分布
df_tr_sdt_pop <- var_both_tr_sdt_model %>%
  tidybayes::gather_draws(`b_.*`, regex = TRUE) %>%
  dplyr::rename(term = .variable,
                value = .value) %>%  # gather_draws会将变量存储为1列，所有的值存储为另一列
  dplyr::ungroup() %>%
  dplyr::mutate(term = gsub("b_", "", term),
                term = dplyr::case_when((term == "Identity自我") ~ "c_Self",
                                              (term == "Identity朋友") ~ "c_Friend",
                                              (term == "Identity生人") ~ "c_Stranger",
                                              (term == "Identity自我:ismatch") ~ "dprime_Self",
                                              (term == "Identity朋友:ismatch") ~ "dprime_Friend",
                                              (term == "Identity生人:ismatch") ~ "dprime_Stranger"),
                      term = factor(term, levels = c("c_Self", "c_Friend", "c_Stranger",
                                                     "dprime_Self", "dprime_Friend", "dprime_Stranger")))

df_tr_sdt_pop

```

```{r}
# 固定效应，条件间差异分布
df_tr_sdt_pop_diff_wide <- df_tr_sdt_pop %>%
  tidyr::pivot_wider(names_from = c(term), values_from = value) %>%
  dplyr::mutate(
    diff_SF_c = c_Self - c_Friend,
    diff_SStr_c = c_Self - c_Stranger ,
    diff_FStr_c = c_Friend - c_Stranger ,
    diff_SF_dprm = dprime_Self - dprime_Friend,
    diff_SStr_dprm = dprime_Self - dprime_Stranger ,
    diff_FStr_dprm = dprime_Friend - dprime_Stranger 
  ) %>%
  dplyr::select(`.chain`, `.iteration`, `.draw`,
    diff_SF_c, diff_SStr_c, diff_FStr_c,
    diff_SF_dprm, diff_SStr_dprm, diff_FStr_dprm
  )

df_tr_sdt_pop_diff_wide

```

```{r}
# 固定效应，后验分布描述
df_tr_sdt_fixed <- df_tr_sdt_pop%>%
  tidyr::pivot_wider(.,
                     id_cols = c('.chain', '.iteration', '.draw'),
                     names_from = term ) %>%
  dplyr::select(-c('.chain', '.iteration', '.draw')) %>%
  bayestestR::describe_posterior(.,
                                 ci = 0.95,
                                 ci_method = 'hdi',
                                 test = c("p_direction", "p_significance"),
                                 centrality = "median") %>%
  tidyr::separate(Parameter, c('params', 'Identity')) %>%
  dplyr::mutate(Identity = factor(Identity, levels = c('Self', 'Friend', 'Stranger')),
                params = factor(params, levels = c('c', 'dprime')))
df_tr_sdt_fixed
```

```{r}
# 各条件中位数及可信区间

med_tr_sdt_Self<- round(df_tr_sdt_fixed$Median[df_tr_sdt_fixed$Identity == 'Self' & df_tr_sdt_fixed$params == 'dprime'], digits = 0)
ll_tr_sdt_Self<- round(df_tr_sdt_fixed$CI_low[df_tr_sdt_fixed$Identity == 'Self' & df_tr_sdt_fixed$params == 'dprime'], digits = 0)
ul_tr_sdt_Self<- round(df_tr_sdt_fixed$CI_high[df_tr_sdt_fixed$Identity == 'Self' & df_tr_sdt_fixed$params == 'dprime'], digits = 0)

med_tr_sdt_Friend<- round(df_tr_sdt_fixed$Median[df_tr_sdt_fixed$Identity == 'Friend' & df_tr_sdt_fixed$params == 'dprime'], digits = 0)
ll_tr_sdt_Friend<- round(df_tr_sdt_fixed$CI_low[df_tr_sdt_fixed$Identity == 'Friend' & df_tr_sdt_fixed$params == 'dprime'], digits = 0)
ul_tr_sdt_Friend<- round(df_tr_sdt_fixed$CI_high[df_tr_sdt_fixed$Identity == 'Friend' & df_tr_sdt_fixed$params == 'dprime'], digits = 0)

med_tr_sdt_Stranger<- round(df_tr_sdt_fixed$Median[df_tr_sdt_fixed$Identity == 'Stranger' & df_tr_sdt_fixed$params == 'dprime'], digits = 0)
ll_tr_sdt_Stranger<- round(df_tr_sdt_fixed$CI_low[df_tr_sdt_fixed$Identity == 'Stranger' & df_tr_sdt_fixed$params == 'dprime'], digits = 0)
ul_tr_sdt_Stranger<- round(df_tr_sdt_fixed$CI_high[df_tr_sdt_fixed$Identity == 'Stranger' & df_tr_sdt_fixed$params == 'dprime'], digits = 0)


```

```{r}
# 基于sexit框架进行统计推断
bayestestR::sexit(df_tr_sdt_pop_diff_wide[,c(7:9)])
```


### （6）结果可视化
```{r}
# 固定效应，后验分布均值图
plot(brms::conditional_effects(var_both_tr_sdt_model),plot = FALSE)[2]
```


```{r}
# p1：绘制各个条件下反应时后验分布（固定效应）

## 固定效应均值
vlines <- df_tr_sdt_pop %>%
  tidyr::separate(term, c('params', 'Identity')) %>%
  dplyr::mutate(Identity = factor(Identity, levels = c('Self', 'Friend', 'Stranger'), labels = c("自我", "朋友", "生人")),
                params = factor(params, levels = c('c', 'dprime'))) %>%
  dplyr::filter(params == 'dprime') %>%
  dplyr::group_by(Identity) %>%
  dplyr::summarize(Mean = mean(value))

## 各个条件RT后验分布
p_sdt_rt <- df_tr_sdt_pop %>%
  tidyr::separate(term, c('params', 'Identity')) %>%
  dplyr::mutate(Identity = factor(Identity, levels = c('Self', 'Friend', 'Stranger'), labels = c("自我", "朋友", "生人")),
                params = factor(params, levels = c('c', 'dprime'))) %>%
  dplyr::filter(params == 'dprime') %>%
  ggplot2::ggplot(aes(x = value, color = Identity)) +
  tidybayes::stat_halfeye(aes(fill = Identity), alpha = 0.6) +
  geom_vline(data = vlines,
             aes(xintercept = Mean, color = Identity),
             linetype = "dashed") +
  scale_colour_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2")+
  ggplot2::labs(x = expression('dprime 后验分布'),
                color = "身份",
                fill = "身份",
                )
# theme_apa()

p_sdt_rt
ggsave(file.path(figDir, "dprime_pop_distribution.png"))
```

```{r}
# p2：绘制各个条件反应时差异的后验分布（固定效应）

# 绘图数据
df_tr_sdt_pop_diff <- df_tr_sdt_pop_diff_wide %>%
  # wide to long
  tidyr::pivot_longer(
    cols = diff_SF_c:diff_FStr_dprm,
    names_to = "term_diff",
    values_to =  "value"
  ) %>%
  dplyr::filter(str_detect(term_diff, '_dprm')) %>%
  dplyr::mutate(term_diff = factor(
    term_diff,
    levels = c(
      'diff_SF_dprm', 'diff_SStr_dprm', 'diff_FStr_dprm'),
    labels = c(
      "dprime[自我] - dprime[朋友]",
      "dprime[自我] - dprime[生人]",
      "dprime[朋友] - dprime[生人]"
    )
  ))



p_tr_sdt_diff <- df_tr_sdt_pop_diff %>%
  ggplot2::ggplot(aes(x = value, fill = after_stat(x > 0))) +   # dprime：self大于friend/stranger(SPE)
  tidybayes::stat_halfeye() +
  geom_vline(xintercept = 0, linetype = "dashed") + # 添加x=0的垂线
  scale_fill_manual(
    values = c('#E74C3C', '#2980B9'),# 蓝色出现在true组，红色出现在false组
    breaks = c(TRUE, FALSE),
    name = "dprime差异" ,
    labels = c(">0", "<0")
  ) +
  xlab("各条件dprime差异分布") +
   facet_wrap( ~ term_diff, nrow = 3, 
              labeller = labeller(term_diff = label_parsed))

p_tr_sdt_diff

ggsave(file.path(figDir, "dprime_diff_compare.png"))

```

## 3、任务无关RT
### （1）模型拟合
```{r}
# fit a three-level hierarchical model for RT, didn't specify the prior, lognormal, effective coding
var_both_tir_rt_model <- df.tir.trial %>%
  dplyr::mutate(rt_sec = rt/1000)%>%
        dplyr::filter(acc == 1) %>%         # only correct trials
        brms::brm(rt_sec ~ Identity* ismatch_num + 
                          (Identity* ismatch_num | subj_idx),
                  family=lognormal(),
                  data = .,
                  chains = 4,
                  warmup = 1000,
                  iter = 5000,
                  thin = 1,
                  control = list(adapt_delta = .95),
                  cores = parallel::detectCores(),
                  backend = 'cmdstanr',  # with cmdstanr
                  save_pars = save_pars(all = TRUE),
                  file = file.path(curDir, "glmmModels/TIR_RT_0.5")
                  )

# rt_sec:数值
# Identity：因子，自我基线
# ismatch_num：数值，-0.5（不匹配），0.5（匹配），ismatch：自我条件下，不匹配向匹配变化

summary(var_both_tir_rt_model)
# Regression Coefficients:
#                          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
# Intercept                   -0.36      0.02    -0.41    -0.32 1.01      919     2228
# Identity朋友                 0.02      0.01     0.00     0.04 1.00     2376     5319
# Identity生人                 0.02      0.01     0.00     0.04 1.00     3566     6540
# ismatch_num                 -0.11      0.01    -0.13    -0.09 1.00     5403     8121
# Identity朋友:ismatch_num     0.00      0.01    -0.02     0.03 1.00     5320     9276
# Identity生人:ismatch_num     0.03      0.01     0.00     0.05 1.00     6522     9697
```

```{r}
# fit a three-level hierarchical model for RT, didn't specify the prior, lognormal, effective coding
# var_both_tir_rt_model <- df.tir.trial %>%
#   dplyr::mutate(rt_sec = rt/1000)%>%
#         dplyr::filter(acc == 1) %>%         # only correct trials
#         brms::brm(rt_sec ~ Identity* ismatch + 
#                           (Identity* ismatch | subj_idx),
#                   family=lognormal(),
#                   data = .,
#                   chains = 4,
#                   warmup = 1000,
#                   iter = 5000, # 5000
#                   thin = 1,
#                   control = list(adapt_delta = .95),
#                   cores = parallel::detectCores(),
#                   backend = 'cmdstanr',  # with cmdstanr
#                   save_pars = save_pars(all = TRUE),
#                   file = file.path(curDir, "glmmModels/TIR_RT_1")
#                   )

# rt_sec:数值
# Identity：因子，自我基线
# ismatch_num：数值，0（不匹配），1（匹配），ismatch：自我条件下，不匹配向匹配变化


# summary(var_both_tir_rt_model)
# Regression Coefficients:
#                      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
# Intercept               -0.31      0.02    -0.35    -0.27 1.00     1889     3401
# Identity朋友             0.02      0.01     0.00     0.04 1.00     5708     8885
# Identity生人             0.01      0.01    -0.01     0.03 1.00     8820    10685
# ismatch                 -0.11      0.01    -0.13    -0.09 1.00     7750     9487
# Identity朋友:ismatch     0.00      0.01    -0.02     0.03 1.00     8863    11010
# Identity生人:ismatch     0.03      0.01     0.00     0.05 1.00     8792    10401
```

### （2）模型评估
```{r}
# ESS、Rhat
summary(var_both_tir_rt_model)
```

```{r}
# 轨迹图(改)
target_pars <- c(
  "b_Intercept",
  "b_Identity朋友",
  "b_Identity生人",
  "b_ismatch_num",
  "b_Identity朋友:ismatch_num",
  "b_Identity生人:ismatch_num"
  )

trace_plot <- bayesplot::mcmc_trace(
  var_both_tir_rt_model, 
  pars = target_pars,
  facet_args = list(nrow = 2, ncol = 3))
trace_plot
# ggsave(file.path(figDir, "trace_plot.png"))
```

```{r}
# 概率密度曲线
p_sample <- bayestestR::estimate_density(var_both_tir_rt_model)
plot(p_sample)
# ggsave(file.path(figDir, "parameters_distribution.png"))

# 同时绘制采样分布与轨迹图
# p_dens <- mcmc_plot(RT_m1, type = "dens", pars = "^b_")
# p_trace <- mcmc_plot(RT_m1, type = "trace", pars = "^b_")
# p_dens + p_trace
```


### （3）模型比较
```{r}
# MAE
calculate_MAE <- function(model_ppc, original_data, y_var = "log_RTs") {
  # 计算每个观测的后验预测均值
  pre_y_mean <- colMeans(model_ppc)
  
  # 构建数据框：预测均值 + 原始观测值
  MAE_df <- data.frame(
    RT_ppc_mean = pre_y_mean,
    RT_original = original_data[[y_var]]  # 提取指定的响应变量观测值
  )
  
  # 计算绝对预测误差
  MAE_df <- MAE_df %>%
    mutate(pre_error = abs(RT_original - RT_ppc_mean))
  
  # 计算误差的中位数
  MAE_value <- median(MAE_df$pre_error, na.rm = TRUE)
  
  return(MAE_value)
}

# 后验预测
rt_var_both_ppc <- posterior_predict(
  object = var_both_tir_rt_model,
)

rt_var_both_mae <- calculate_MAE(rt_var_both_ppc, var_both_tir_rt_model$data, "rt_sec")

```

```{r}
# loo
loo <- loo::loo(var_both_tir_rt_model)
```


### （4）后验预测检验
```{r}
# performance::check_predictions(RT_m1, check_range = TRUE)
bayesplot::pp_check(var_both_tir_rt_model, type = "dens_overlay", ndraws = 1000)
# ggsave(file.path(figDir, "modle_estimation.png"))
```


### （5）推断统计
```{r}
# 固定效应，各个条件下反应时分布
df_tir_rt_pop <- var_both_tir_rt_model %>%
  tidybayes::gather_draws(`b_.*`, regex = TRUE) %>%
  dplyr::rename(term = .variable,
                pop_mean = .value) %>%  # gather_draws会将变量存储为1列，所有的值存储为另一列
  dplyr::ungroup() %>%
  dplyr::mutate(term = gsub("b_", "", term))%>%
  tidyr::pivot_wider(names_from = c(term), values_from = pop_mean) %>%   # long to wide
  # 计算各条件反应时分布
  dplyr::mutate(
    Self_NonMatch = Intercept,   #  self和nonmatch被编码为0              
    Friend_NonMatch = Intercept  + Identity朋友,
    Stranger_NonMatch = Intercept  + Identity生人,
    Self_Match = Intercept + ismatch_num,             
    Friend_Match = Intercept + ismatch_num + Identity朋友 + `Identity朋友:ismatch_num`,
    Stranger_Match = Intercept + ismatch_num + Identity生人 + `Identity生人:ismatch_num`)%>%
  dplyr::select(`.chain`, `.iteration`, `.draw`,
                Self_Match, Friend_Match, Stranger_Match,
                Self_NonMatch, Friend_NonMatch, Stranger_NonMatch) %>%
  # wide to long
  tidyr::pivot_longer(cols = Self_Match:Stranger_NonMatch, names_to = "term", values_to =  "value") %>%  
  dplyr::mutate(term = factor(term, levels = c(
                'Self_Match', 'Friend_Match', 'Stranger_Match',
                'Self_NonMatch', 'Friend_NonMatch', 'Stranger_NonMatch'
  )),
  # log还原
  value = exp(value),
  value = value *1000)

df_tir_rt_pop

```


```{r}
# 固定效应，条件间差异分布
df_tir_rt_pop_diff_wide <- df_tir_rt_pop %>%
  tidyr::pivot_wider(names_from = c(term), values_from = value) %>%
  dplyr::mutate(
    diff_SF_Match = Friend_Match - Self_Match,
    diff_SStr_Match = Stranger_Match - Self_Match ,
    diff_FStr_Match = Stranger_Match - Friend_Match,
    diff_SF_NonMatch = Friend_NonMatch - Self_NonMatch,
    diff_SStr_NonMatch = Stranger_NonMatch - Self_NonMatch,
    diff_FStr_NonMatch = Stranger_NonMatch - Friend_NonMatch
  ) %>%
  dplyr::select(`.chain`, `.iteration`, `.draw`,
    diff_SF_Match, diff_SStr_Match, diff_FStr_Match,
    diff_SF_NonMatch, diff_SStr_NonMatch, diff_FStr_NonMatch
  )

df_tir_rt_pop_diff_wide

```

```{r}
# 固定效应，后验分布描述
df_tir_rt_fixed <- df_tir_rt_pop%>%
  tidyr::pivot_wider(.,
                     id_cols = c('.chain', '.iteration', '.draw'),
                     names_from = term ) %>%
  dplyr::select(-c('.chain', '.iteration', '.draw')) %>%
  bayestestR::describe_posterior(.,
                                 ci = 0.95,
                                 ci_method = 'hdi',
                                 test = c("p_direction", "p_significance"),
                                 centrality = "median") %>%
  tidyr::separate(Parameter, c('Identity', 'ismatch')) %>%
  dplyr::mutate(Identity = factor(Identity, levels = c('Self', 'Friend', 'Stranger')),
                ismatch = factor(ismatch, levels = c('Match', 'NonMatch')))
```

```{r}
# 各条件中位数及可信区间

## 匹配条件
med_tir_rt_Self_Match<- round(df_tir_rt_fixed$Median[df_tir_rt_fixed$Identity == 'Self' & df_tir_rt_fixed$ismatch == 'Match'], digits = 0)
ll_tir_rt_Self_Match<- round(df_tir_rt_fixed$CI_low[df_tir_rt_fixed$Identity == 'Self' & df_tir_rt_fixed$ismatch == 'Match'], digits = 0)
ul_tir_rt_Self_Match<- round(df_tir_rt_fixed$CI_high[df_tir_rt_fixed$Identity == 'Self' & df_tir_rt_fixed$ismatch == 'Match'], digits = 0)

med_tir_rt_Friend_Match<- round(df_tir_rt_fixed$Median[df_tir_rt_fixed$Identity == 'Friend' & df_tir_rt_fixed$ismatch == 'Match'], digits = 0)
ll_tir_rt_Friend_Match<- round(df_tir_rt_fixed$CI_low[df_tir_rt_fixed$Identity == 'Friend' & df_tir_rt_fixed$ismatch == 'Match'], digits = 0)
ul_tir_rt_Friend_Match<- round(df_tir_rt_fixed$CI_high[df_tir_rt_fixed$Identity == 'Friend' & df_tir_rt_fixed$ismatch == 'Match'], digits = 0)

med_tir_rt_Stranger_Match<- round(df_tir_rt_fixed$Median[df_tir_rt_fixed$Identity == 'Stranger' & df_tir_rt_fixed$ismatch == 'Match'], digits = 0)
ll_tir_rt_Stranger_Match<- round(df_tir_rt_fixed$CI_low[df_tir_rt_fixed$Identity == 'Stranger' & df_tir_rt_fixed$ismatch == 'Match'], digits = 0)
ul_tir_rt_Stranger_Match<- round(df_tir_rt_fixed$CI_high[df_tir_rt_fixed$Identity == 'Stranger' & df_tir_rt_fixed$ismatch == 'Match'], digits = 0)


## 不匹配条件
med_tir_rt_Self_NonMatch<- round(df_tir_rt_fixed$Median[df_tir_rt_fixed$Identity == 'Self' & df_tir_rt_fixed$ismatch == 'NonMatch'], digits = 0)
ll_tir_rt_Self_NonMatch<- round(df_tir_rt_fixed$CI_low[df_tir_rt_fixed$Identity == 'Self' & df_tir_rt_fixed$ismatch == 'NonMatch'], digits = 0)
ul_tir_rt_Self_NonMatch<- round(df_tir_rt_fixed$CI_high[df_tir_rt_fixed$Identity == 'Self' & df_tir_rt_fixed$ismatch == 'NonMatch'], digits = 0)

med_tir_rt_Friend_NonMatch<- round(df_tir_rt_fixed$Median[df_tir_rt_fixed$Identity == 'Friend' & df_tir_rt_fixed$ismatch == 'NonMatch'], digits = 0)
ll_tir_rt_Friend_NonMatch<- round(df_tir_rt_fixed$CI_low[df_tir_rt_fixed$Identity == 'Friend' & df_tir_rt_fixed$ismatch == 'NonMatch'], digits = 0)
ul_tir_rt_Friend_NonMatch<- round(df_tir_rt_fixed$CI_high[df_tir_rt_fixed$Identity == 'Friend' & df_tir_rt_fixed$ismatch == 'NonMatch'], digits = 0)

med_tir_rt_Stranger_NonMatch<- round(df_tir_rt_fixed$Median[df_tir_rt_fixed$Identity == 'Stranger' & df_tir_rt_fixed$ismatch == 'NonMatch'], digits = 0)
ll_tir_rt_Stranger_NonMatch<- round(df_tir_rt_fixed$CI_low[df_tir_rt_fixed$Identity == 'Stranger' & df_tir_rt_fixed$ismatch == 'NonMatch'], digits = 0)
ul_tir_rt_Stranger_NonMatch<- round(df_tir_rt_fixed$CI_high[df_tir_rt_fixed$Identity == 'Stranger' & df_tir_rt_fixed$ismatch == 'NonMatch'], digits = 0)

```

```{r}
# 基于sexit框架进行统计推断（改）
bayestestR::sexit(df_tir_rt_pop_diff_wide[,c(4:9)])
```


### （6）结果可视化
```{r}
# 固定效应，后验分布均值图
plot(conditional_effects(var_both_tir_rt_model),plot = FALSE)[3]
```


```{r}
# p1：绘制各个条件下反应时后验分布（固定效应）

## 固定效应均值
vlines <- df_tir_rt_pop %>%
  tidyr::separate(term, c('Identity', 'ismatch')) %>%
  dplyr::mutate(Identity = factor(Identity, levels = c('Self', 'Friend', 'Stranger'), labels = c("自我", "朋友", "生人")),
                ismatch = factor(ismatch, levels = c('Match', 'NonMatch'), labels = c("匹配", "不匹配"))) %>%
  dplyr::group_by(Identity, ismatch) %>%
  dplyr::summarize(Mean = mean(value))

## 各个条件RT后验分布
p_tir_rt <- df_tir_rt_pop %>%
  tidyr::separate(term, c('Identity', 'ismatch')) %>%
  dplyr::mutate(Identity = factor(Identity, levels = c('Self', 'Friend', 'Stranger'), labels = c("自我", "朋友", "生人")),
                ismatch = factor(ismatch, levels = c('Match', 'NonMatch'), labels = c("匹配", "不匹配"))) %>%
  ggplot2::ggplot(., aes(x = value, color = Identity)) +
  tidybayes::stat_halfeye(aes(fill = Identity), alpha = 0.6) +
  geom_vline(data = vlines,
             aes(xintercept = Mean, color = Identity),
             linetype = "dashed") +
  facet_wrap( ~ ismatch, nrow = 2) +
  scale_colour_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2")+
  ggplot2::labs(x = expression('反应时后验分布'),
                color = "身份",
                fill = "身份",
                )
# theme_apa()
p_tir_rt
```

```{r}
# p2：绘制各个条件反应时差异的后验分布（固定效应）

# 绘图数据
df_tir_rt_pop_diff <- df_tir_rt_pop_diff_wide %>%
  # wide to long
  tidyr::pivot_longer(
    cols = diff_SF_Match:diff_FStr_NonMatch,
    names_to = "term_diff",
    values_to =  "value"
  ) %>%
  dplyr::mutate(term_diff = factor(
    term_diff,
    levels = c(
      'diff_SF_Match','diff_SStr_Match','diff_FStr_Match',
      'diff_SF_NonMatch', 'diff_SStr_NonMatch', 'diff_FStr_NonMatch'),
    labels = c(
      "(RT[自我] - RT[朋友])[匹配]",
      "(RT[自我] - RT[生人])[匹配]",
      "(RT[朋友] - RT[生人])[匹配]",
      "(RT[自我] - RT[朋友])[不匹配]",
      "(RT[自我] - RT[生人])[不匹配]",
      "(RT[朋友] - RT[生人])[不匹配]"
    )
  ))


p_tir_rt_diff <- df_tir_rt_pop_diff %>%
  ggplot2::ggplot(aes(x = value, fill = after_stat(x > 0))) +   # RT：self快于friend/stranger(SPE)
  tidybayes::stat_halfeye() +
  geom_vline(xintercept = 0, linetype = "dashed") + # 添加x=0的垂线
  scale_fill_manual(
    values = c('#E74C3C', '#2980B9'),
    breaks = c(TRUE, FALSE),
    name = "反应时差异" ,
    labels = c(">0", "<0")
  ) +
  xlab("各条件反应时差异后验分布") +
 facet_wrap( ~ term_diff, nrow = 2, 
              labeller = labeller(term_diff = label_parsed))

p_tir_rt_diff

# ggsave(file.path(figDir, "diff_compare.png"))

```

## 4、任务无关ACC：信号检测论
### （1）模型拟合
```{r}
# fit a three-level hierarchical model for RT, didn't specify the prior, lognormal, effective coding
var_both_tir_sdt_model <- brms::brm(saymatch ~ 0 + Identity + Identity:ismatch + 
                          (0 + Identity + Identity:ismatch | subj_idx),
                  family = bernoulli(link="probit"), 
                  data = df.tir.trial,
                  chains = 4,
                  warmup = 1000,
                  iter = 5000,# 5000
                  thin = 1,
                  control = list(adapt_delta = .95),
                  cores = parallel::detectCores(),
                  backend = 'cmdstanr',  # with cmdstanr
                  save_pars = save_pars(all = TRUE),
                  file = file.path(curDir, "glmmModels/TIR_sdt")
                  )

# saymatch:数值
# Identity：因子，自我基线
# ismatch：数值，1匹配，0不匹配
```

### （2）模型评估
```{r}
# ESS、Rhat
summary(var_both_tir_sdt_model)

# Regression Coefficients:
#                      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
# Identity自我            -1.46      0.07    -1.61    -1.32 1.00     5942     8561
# Identity朋友            -1.44      0.06    -1.57    -1.33 1.00     7453     9243
# Identity生人            -1.45      0.07    -1.59    -1.32 1.00     7376     9583
# Identity自我:ismatch     2.92      0.13     2.67     3.18 1.00     6257     8387
# Identity朋友:ismatch     2.80      0.11     2.59     3.02 1.00     7272     9302
# Identity生人:ismatch     2.75      0.11     2.53     2.96 1.00     6661     9392
```

```{r}
# 轨迹图
target_pars <- c(
  "b_Identity自我",
  "b_Identity朋友",
  "b_Identity生人",
  "b_Identity自我:ismatch",
  "b_Identity朋友:ismatch",
  "b_Identity生人:ismatch"
  )

trace_plot <- bayesplot::mcmc_trace(
  var_both_tir_sdt_model, 
  pars = target_pars,
  facet_args = list(nrow = 2, ncol = 3))
trace_plot
# ggsave(file.path(figDir, "trace_plot.png"))
```

```{r}
# 概率密度曲线
p_sample <- bayestestR::estimate_density(var_both_tir_sdt_model)
plot(p_sample)
# ggsave(file.path(figDir, "parameters_distribution.png"))

# 同时绘制采样分布与轨迹图
# p_dens <- mcmc_plot(RT_m1, type = "dens", pars = "^b_")
# p_trace <- mcmc_plot(RT_m1, type = "trace", pars = "^b_")
# p_dens + p_trace
```


### （3）模型比较
```{r}
# MAE
calculate_MAE <- function(model_ppc, original_data, y_var = "log_RTs") {
  # 计算每个观测的后验预测均值
  pre_y_mean <- colMeans(model_ppc)
  
  # 构建数据框：预测均值 + 原始观测值
  MAE_df <- data.frame(
    RT_ppc_mean = pre_y_mean,
    RT_original = original_data[[y_var]]  # 提取指定的响应变量观测值
  )
  
  # 计算绝对预测误差
  MAE_df <- MAE_df %>%
    mutate(pre_error = abs(RT_original - RT_ppc_mean))
  
  # 计算误差的中位数
  MAE_value <- median(MAE_df$pre_error, na.rm = TRUE)
  
  return(MAE_value)
}

# 后验预测
tir_sdt_var_both_ppc <- posterior_predict(
  object = var_both_tir_sdt_model,
)

tir_sdt_var_both_mae <- calculate_MAE(tir_sdt_var_both_ppc, var_both_tir_sdt_model$data, "saymatch")

```

```{r}
# loo
loo <- loo::loo(var_both_tir_sdt_model)
```


### （4）后验预测检验
```{r}
# performance::check_predictions(RT_m1, check_range = TRUE)
bayesplot::pp_check(var_both_tir_sdt_model, type = "dens_overlay", ndraws = 1000)
# ggsave(file.path(figDir, "modle_estimation.png"))
```


### （5）推断统计
```{r}
# 固定效应，各个条件下参数分布
df_tir_sdt_pop <- var_both_tir_sdt_model %>%
  tidybayes::gather_draws(`b_.*`, regex = TRUE) %>%
  dplyr::rename(term = .variable,
                value = .value) %>%  # gather_draws会将变量存储为1列，所有的值存储为另一列
  dplyr::ungroup() %>%
  dplyr::mutate(term = gsub("b_", "", term),
                term = dplyr::case_when((term == "Identity自我") ~ "c_Self",
                                              (term == "Identity朋友") ~ "c_Friend",
                                              (term == "Identity生人") ~ "c_Stranger",
                                              (term == "Identity自我:ismatch") ~ "dprime_Self",
                                              (term == "Identity朋友:ismatch") ~ "dprime_Friend",
                                              (term == "Identity生人:ismatch") ~ "dprime_Stranger"),
                      term = factor(term, levels = c("c_Self", "c_Friend", "c_Stranger",
                                                     "dprime_Self", "dprime_Friend", "dprime_Stranger")))

df_tir_sdt_pop

```

```{r}
# 固定效应，条件间差异分布
df_tir_sdt_pop_diff_wide <- df_tir_sdt_pop %>%
  tidyr::pivot_wider(names_from = c(term), values_from = value) %>%
  dplyr::mutate(
    diff_SF_c = c_Self - c_Friend,
    diff_SStr_c = c_Self - c_Stranger ,
    diff_FStr_c = c_Friend - c_Stranger ,
    diff_SF_dprm = dprime_Self - dprime_Friend,
    diff_SStr_dprm = dprime_Self - dprime_Stranger ,
    diff_FStr_dprm = dprime_Friend - dprime_Stranger 
  ) %>%
  dplyr::select(`.chain`, `.iteration`, `.draw`,
    diff_SF_c, diff_SStr_c, diff_FStr_c,
    diff_SF_dprm, diff_SStr_dprm, diff_FStr_dprm
  )

df_tir_sdt_pop_diff_wide

```

```{r}
# 固定效应，后验分布描述
df_tir_sdt_fixed <- df_tir_sdt_pop%>%
  tidyr::pivot_wider(.,
                     id_cols = c('.chain', '.iteration', '.draw'),
                     names_from = term ) %>%
  dplyr::select(-c('.chain', '.iteration', '.draw')) %>%
  bayestestR::describe_posterior(.,
                                 ci = 0.95,
                                 ci_method = 'hdi',
                                 test = c("p_direction", "p_significance"),
                                 centrality = "median") %>%
  tidyr::separate(Parameter, c('params', 'Identity')) %>%
  dplyr::mutate(Identity = factor(Identity, levels = c('Self', 'Friend', 'Stranger')),
                params = factor(params, levels = c('c', 'dprime')))
```

```{r}
# 各条件中位数及可信区间

med_tir_sdt_Self<- round(df_tir_sdt_fixed$Median[df_tir_sdt_fixed$Identity == 'Self' & df_tir_sdt_fixed$params == 'dprime'], digits = 0)
ll_tir_sdt_Self<- round(df_tir_sdt_fixed$CI_low[df_tir_sdt_fixed$Identity == 'Self' & df_tir_sdt_fixed$params == 'dprime'], digits = 0)
ul_tir_sdt_Self<- round(df_tir_sdt_fixed$CI_high[df_tir_sdt_fixed$Identity == 'Self' & df_tir_sdt_fixed$params == 'dprime'], digits = 0)

med_tir_sdt_Friend<- round(df_tir_sdt_fixed$Median[df_tir_sdt_fixed$Identity == 'Friend' & df_tir_sdt_fixed$params == 'dprime'], digits = 0)
ll_tir_sdt_Friend<- round(df_tir_sdt_fixed$CI_low[df_tir_sdt_fixed$Identity == 'Friend' & df_tir_sdt_fixed$params == 'dprime'], digits = 0)
ul_tir_sdt_Friend<- round(df_tir_sdt_fixed$CI_high[df_tir_sdt_fixed$Identity == 'Friend' & df_tir_sdt_fixed$params == 'dprime'], digits = 0)

med_tir_sdt_Stranger<- round(df_tir_sdt_fixed$Median[df_tir_sdt_fixed$Identity == 'Stranger' & df_tir_sdt_fixed$params == 'dprime'], digits = 0)
ll_tir_sdt_Stranger<- round(df_tir_sdt_fixed$CI_low[df_tir_sdt_fixed$Identity == 'Stranger' & df_tir_sdt_fixed$params == 'dprime'], digits = 0)
ul_tir_sdt_Stranger<- round(df_tir_sdt_fixed$CI_high[df_tir_sdt_fixed$Identity == 'Stranger' & df_tir_sdt_fixed$params == 'dprime'], digits = 0)


```

```{r}
# 基于sexit框架进行统计推断
bayestestR::sexit(df_tir_sdt_pop_diff_wide[,c(7:9)])
```


### （6）结果可视化
```{r}
# 固定效应，后验分布均值图
plot(conditional_effects(var_both_tir_sdt_model),plot = FALSE)[2]
```


```{r}
# p1：绘制各个条件下反应时后验分布（固定效应）

## 固定效应均值
vlines <- df_tir_sdt_pop %>%
  tidyr::separate(term, c('params', 'Identity')) %>%
  dplyr::mutate(Identity = factor(Identity, levels = c('Self', 'Friend', 'Stranger'),  labels = c("自我", "朋友", "生人")),
                params = factor(params, levels = c('c', 'dprime'))) %>%
  dplyr::filter(params == 'dprime') %>%
  dplyr::group_by(Identity) %>%
  dplyr::summarize(Mean = mean(value))

## 各个条件RT后验分布
p_sdt <- df_tir_sdt_pop %>%
  tidyr::separate(term, c('params', 'Identity')) %>%
  dplyr::mutate(Identity = factor(Identity, levels = c('Self', 'Friend', 'Stranger'),  labels = c("自我", "朋友", "生人")),
                params = factor(params, levels = c('c', 'dprime'))) %>%
  dplyr::filter(params == 'dprime') %>%
  ggplot2::ggplot(aes(x = value, color = Identity)) +
  tidybayes::stat_halfeye(aes(fill = Identity), alpha = 0.6) +
  geom_vline(data = vlines,
             aes(xintercept = Mean, color = Identity),
             linetype = "dashed") +
  labs(x = expression('Posteior distribution of reaction times')) +
  scale_colour_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2")+
  ggplot2::labs(x = expression('dprime 后验分布'),
                color = "身份",
                fill = "身份",
                )
# theme_apa()

p_sdt
```

```{r}
# p2：绘制各个条件反应时差异的后验分布（固定效应）

# 绘图数据
df_tir_sdt_pop_diff <- df_tir_sdt_pop_diff_wide %>%
  # wide to long
  tidyr::pivot_longer(
    cols = diff_SF_c:diff_FStr_dprm,
    names_to = "term_diff",
    values_to =  "value"
  ) %>%
  dplyr::filter(str_detect(term_diff, '_dprm')) %>%
  dplyr::mutate(term_diff = factor(
    term_diff,
    levels = c(
      'diff_SF_dprm', 'diff_SStr_dprm', 'diff_FStr_dprm'),
    labels = c(
      "dprime[自我] - dprime[朋友]",
      "dprime[自我] - dprime[生人]",
      "dprime[朋友] - dprime[生人]"
    )
  ))



p_tir_sdt_diff <- df_tir_sdt_pop_diff %>%
  ggplot2::ggplot(aes(x = value, fill = after_stat(x > 0))) +   # dprime：self大于friend/stranger(SPE)
  tidybayes::stat_halfeye() +
  geom_vline(xintercept = 0, linetype = "dashed") + # 添加x=0的垂线
  scale_fill_manual(
    values = c('#E74C3C', '#2980B9'),
    breaks = c(TRUE, FALSE),
    name = "dprime差异" ,
    labels = c(">0", "<0")
  ) +
  xlab("各条件dprime差异分布") +
  facet_wrap( ~ term_diff, nrow = 3, 
              labeller = labeller(term_diff = label_parsed)) 

p_tir_sdt_diff

# ggsave(file.path(figDir, "diff_compare.png"))

```


